{"version":3,"file":"index.cjs.js","sources":["../src/dialects/SchemaDialect.ts","../src/utils/pick.ts","../src/dialects/Base/accessors/getAnnotations.ts","../src/utils/guards.ts","../src/dialects/accessors/guards/values.ts","../src/dialects/Base/accessors/getValidations.ts","../src/dialects/Base/SharedDialect.ts","../src/dialects/JSONSchema/accessors/getAnnotations.ts","../src/nodes/types.ts","../src/dialects/JSONSchema/accessors/getCombiners.ts","../src/dialects/accessors/getMatchingValidations.ts","../src/dialects/JSONSchema/accessors/getValidations.ts","../src/dialects/JSONSchema/Draft7.ts","../src/dialects/OAS/accessors/getAnnotations.ts","../src/dialects/OAS/accessors/getCombiners.ts","../src/dialects/OAS/accessors/getValidations.ts","../src/dialects/OAS/OAS2.ts","../src/nodes/BaseNode.ts","../src/nodes/mirrored/MirroredReferenceNode.ts","../src/nodes/mirrored/MirroredRegularNode.ts","../src/dialects/accessors/unwrap.ts","../src/nodes/ReferenceNode.ts","../src/dialects/accessors/getPrimaryType.ts","../src/dialects/accessors/guards/isValidType.ts","../src/dialects/accessors/inferType.ts","../src/dialects/accessors/getTypes.ts","../src/nodes/RegularNode.ts","../src/nodes/RootNode.ts","../src/guards/nodes.ts","../src/errors.ts","../src/mergers/mergeAllOf.ts","../src/mergers/mergeOneOrAnyOf.ts","../src/walker/walker.ts","../src/tree/tree.ts"],"sourcesContent":["import type { SchemaCombinerName, SchemaNodeKind } from '../nodes';\nimport type { SchemaFragment } from '../types';\n\nexport abstract class SchemaDialect {\n  public abstract readonly id: string;\n\n  abstract getCombiners(fragment: SchemaFragment): Set<SchemaCombinerName>;\n  abstract getValidations(fragment: SchemaFragment, types: Set<SchemaNodeKind>): Record<string, unknown>;\n  abstract getAnnotations(fragment: SchemaFragment): Record<string, unknown>;\n}\n","import type { Dictionary } from '@stoplight/types';\n\nexport function pick(target: object, keys: readonly (string | number)[]) {\n  const source: Dictionary<unknown, string | number> = {};\n\n  for (const key of keys) {\n    if (key in target) {\n      source[key] = target[key];\n    }\n  }\n\n  return source;\n}\n","import type { SchemaFragment } from '../../../types';\nimport { pick } from '../../../utils/pick';\n\nconst ANNOTATIONS = ['description', 'default'] as const;\n\nexport function getAnnotations(fragment: SchemaFragment) {\n  return pick(fragment, ANNOTATIONS);\n}\n","import type { Dictionary } from '@stoplight/types';\n\nexport function isStringOrNumber(value: unknown): value is number | string {\n  return typeof value === 'string' || typeof value === 'number';\n}\n\nexport function isObject(maybeObj: unknown): maybeObj is object {\n  return maybeObj !== void 0 && maybeObj !== null && typeof maybeObj === 'object';\n}\n\nexport function isPrimitive(\n  maybePrimitive: unknown,\n): maybePrimitive is string | number | boolean | undefined | null | symbol | bigint {\n  return typeof maybePrimitive !== 'function' && !isObject(maybePrimitive);\n}\n\nexport function isObjectLiteral(maybeObj: unknown): maybeObj is Dictionary<unknown> {\n  if (isPrimitive(maybeObj) === true) return false;\n  const proto = Object.getPrototypeOf(maybeObj);\n  return proto === null || proto === Object.prototype;\n}\n\nexport function isNonNullable<T = unknown>(maybeNullable: T): maybeNullable is NonNullable<T> {\n  return maybeNullable !== void 0 && maybeNullable !== null;\n}\n","export const isNumber = (value: unknown): value is number => typeof value === 'number';\nexport const isString = (value: unknown): value is string => typeof value === 'string';\nexport const isBoolean = (value: unknown): value is boolean => typeof value === 'boolean';\n","import type { Dictionary } from '@stoplight/types';\n\nimport type { SchemaNodeKind } from '../../../nodes/types';\nimport type { SchemaFragment } from '../../../types';\nimport { isObjectLiteral } from '../../../utils';\nimport { isBoolean, isNumber, isString } from '../../accessors/guards/values';\nimport type { Validator } from '../../types';\n\nconst COMMON_VALIDATION_TYPES: Validator[] = [\n  {\n    key: 'readOnly',\n    value: isBoolean,\n  },\n  {\n    key: 'writeOnly',\n    value: isBoolean,\n  },\n];\n\nconst VALIDATION_TYPES: Partial<Record<SchemaNodeKind, Validator[]>> = {\n  string: [\n    {\n      key: 'minLength',\n      value: isNumber,\n    },\n    {\n      key: 'maxLength',\n      value: isNumber,\n    },\n    {\n      key: 'pattern',\n      value: isString,\n    },\n  ],\n  number: [\n    {\n      key: 'multipleOf',\n      value: isNumber,\n    },\n    {\n      key: 'minimum',\n      value: isNumber,\n    },\n    {\n      key: 'maximum',\n      value: isNumber,\n    },\n  ],\n  get integer() {\n    return this.number;\n  },\n  object: [\n    {\n      key: 'additionalProperties',\n      value: (value: unknown): value is SchemaFragment | boolean => isObjectLiteral(value) || isBoolean(value),\n    },\n    { key: 'minProperties', value: isNumber },\n    { key: 'maxProperties', value: isNumber },\n    {\n      key: 'required',\n      value: (value: unknown): value is string[] => Array.isArray(value) && value.every(isString),\n    },\n  ],\n  array: [\n    {\n      key: 'additionalItems',\n      value: (value: unknown): value is SchemaFragment | SchemaFragment[] | boolean =>\n        isObjectLiteral(value) || isBoolean(value),\n    },\n    { key: 'minItems', value: isNumber },\n    { key: 'maxItems', value: isNumber },\n    { key: 'uniqueItems', value: isBoolean },\n  ],\n};\n\nfunction getTypeValidations(types: Set<SchemaNodeKind>): Validator[] {\n  const extraValidations: Validator[] = [];\n\n  for (const type of types) {\n    const value = VALIDATION_TYPES[type];\n    if (value !== void 0) {\n      extraValidations.push(...value);\n    }\n  }\n\n  return extraValidations;\n}\n\nexport function getValidations(fragment: SchemaFragment, types: Set<SchemaNodeKind>): Dictionary<unknown> {\n  const availableValidations = [...COMMON_VALIDATION_TYPES, ...(types === null ? [] : getTypeValidations(types))];\n  const values = {};\n\n  for (const { key, value } of availableValidations) {\n    if (key in fragment && value(fragment[key])) {\n      values[key] = fragment[key];\n    }\n  }\n\n  return values;\n}\n","import { observable } from 'mobx';\n\nimport type { SchemaCombinerName, SchemaNodeKind } from '../../nodes';\nimport type { SchemaFragment } from '../../types';\nimport { SchemaDialect } from '../SchemaDialect';\nimport { getAnnotations } from './accessors/getAnnotations';\nimport { getValidations } from './accessors/getValidations';\n\nexport class SharedSchemaDialect extends SchemaDialect {\n  public readonly id = 'shared';\n\n  public getCombiners(_fragment: SchemaFragment) {\n    return new Set<SchemaCombinerName>();\n  }\n\n  public getAnnotations(fragment: SchemaFragment): Record<string, unknown> {\n    return observable.object(getAnnotations(fragment));\n  }\n\n  public getValidations(fragment: SchemaFragment, types: Set<SchemaNodeKind>): Record<string, unknown> {\n    return observable(getValidations(fragment, types));\n  }\n}\n","import type { SchemaFragment } from '../../../types';\n\nexport function getAnnotations(fragment: SchemaFragment) {\n  return {\n    ...(Array.isArray(fragment.examples) ? { examples: fragment.examples } : null),\n    // @ts-ignore\n    ...(fragment.deprecated === true ? { deprecated: fragment.deprecated } : null),\n  };\n}\n","import type { MirroredReferenceNode } from './mirrored/MirroredReferenceNode';\nimport type { MirroredRegularNode } from './mirrored/MirroredRegularNode';\nimport type { ReferenceNode } from './ReferenceNode';\nimport type { RegularNode } from './RegularNode';\nimport type { RootNode } from './RootNode';\n\nexport type MirroredSchemaNode = MirroredRegularNode | MirroredReferenceNode;\n\nexport type SchemaNode = RootNode | RegularNode | ReferenceNode | MirroredSchemaNode;\n\nexport enum SchemaNodeKind {\n  Any = 'any',\n  String = 'string',\n  Number = 'number',\n  Integer = 'integer',\n  Boolean = 'boolean',\n  Null = 'null',\n  Array = 'array',\n  Object = 'object',\n}\n\nexport enum SchemaCombinerName {\n  AllOf = 'allOf',\n  AnyOf = 'anyOf',\n  OneOf = 'oneOf',\n}\n","import { SchemaCombinerName } from '../../../nodes/types';\nimport type { SchemaFragment } from '../../../types';\n\nexport function getCombiners(fragment: SchemaFragment): SchemaCombinerName[] {\n  const combiners: SchemaCombinerName[] = [];\n\n  if (SchemaCombinerName.AnyOf in fragment) {\n    combiners.push(SchemaCombinerName.AnyOf);\n  }\n\n  if (SchemaCombinerName.OneOf in fragment) {\n    combiners.push(SchemaCombinerName.OneOf);\n  }\n\n  if (SchemaCombinerName.AllOf in fragment) {\n    combiners.push(SchemaCombinerName.AllOf);\n  }\n\n  return combiners;\n}\n","import type { SchemaNodeKind } from '../../nodes/types';\nimport type { SchemaFragment } from '../../types';\nimport type { Validations, Validator } from '../types';\n\nfunction getTypeValidations(validations: Validations, types: Set<SchemaNodeKind>): Validator[] {\n  const matchedValidations: Validator[] = [];\n\n  for (const type of types) {\n    const value = validations[type];\n    if (value !== void 0) {\n      matchedValidations.push(...value);\n    }\n  }\n\n  return matchedValidations;\n}\n\nexport function getMatchingValidations(\n  fragment: SchemaFragment,\n  validations: Validations,\n  types: Set<SchemaNodeKind>,\n): Record<string, unknown> {\n  const availableValidations = getTypeValidations(validations, types);\n  const values = {};\n\n  for (const { key, value } of availableValidations) {\n    if (key in fragment && value(fragment[key])) {\n      values[key] = fragment[key];\n    }\n  }\n\n  return values;\n}\n","import type { SchemaNodeKind } from '../../../nodes';\nimport type { SchemaFragment } from '../../../types';\nimport { getMatchingValidations } from '../../accessors/getMatchingValidations';\nimport { isNumber } from '../../accessors/guards/values';\nimport type { Validations } from '../../types';\n\nconst VALIDATION_TYPES: Validations = {\n  number: [\n    {\n      key: 'exclusiveMaximum',\n      value: isNumber,\n    },\n    {\n      key: 'exclusiveMinimum',\n      value: isNumber,\n    },\n  ],\n  get integer() {\n    return this.number;\n  },\n};\n\nexport function getValidations(schema: SchemaFragment, types: Set<SchemaNodeKind>): Record<string, unknown> {\n  return getMatchingValidations(schema, VALIDATION_TYPES, types);\n}\n","import { observable } from 'mobx';\n\nimport type { SchemaCombinerName, SchemaNodeKind } from '../../nodes';\nimport type { SchemaFragment } from '../../types';\nimport { SharedSchemaDialect } from '../Base/SharedDialect';\nimport { getAnnotations } from './accessors/getAnnotations';\nimport { getCombiners } from './accessors/getCombiners';\nimport { getValidations } from './accessors/getValidations';\n\nexport class JSONSchemaDraft7Dialect extends SharedSchemaDialect {\n  public getCombiners(fragment: SchemaFragment): Set<SchemaCombinerName> {\n    return observable.set(getCombiners(fragment));\n  }\n\n  public getAnnotations(fragment: SchemaFragment): Record<string, unknown> {\n    return observable.object({\n      ...super.getAnnotations(fragment),\n      ...getAnnotations(fragment),\n    });\n  }\n\n  public getValidations(fragment: SchemaFragment, types: Set<SchemaNodeKind>): Record<string, unknown> {\n    return observable({\n      ...super.getValidations(fragment, types),\n      ...getValidations(fragment, types),\n    });\n  }\n}\n","import type { SchemaFragment } from '../../../types';\n\nexport function getAnnotations(fragment: SchemaFragment) {\n  return {\n    ...('x-example' in fragment ? fragment['x-example'] : null),\n    // @ts-ignore\n    ...(fragment['x-deprecated'] === true ? { deprecated: true } : null),\n  };\n}\n","import { observable } from 'mobx';\n\nimport { SchemaCombinerName } from '../../../nodes/types';\nimport type { SchemaFragment } from '../../../types';\n\nexport function getCombiners(fragment: SchemaFragment): Set<SchemaCombinerName> {\n  const combiners: SchemaCombinerName[] = [];\n\n  if (SchemaCombinerName.AllOf in fragment) {\n    combiners.push(SchemaCombinerName.AllOf);\n  }\n\n  return observable.set(combiners);\n}\n","import { observable } from 'mobx';\n\nimport type { SchemaNodeKind } from '../../../nodes';\nimport type { SchemaFragment } from '../../../types';\nimport { getMatchingValidations } from '../../accessors/getMatchingValidations';\nimport { isNumber } from '../../accessors/guards/values';\nimport type { Validations } from '../../types';\n\nconst VALIDATION_TYPES: Validations = {\n  number: [\n    {\n      key: 'exclusiveMaximum',\n      value: isNumber,\n    },\n    {\n      key: 'exclusiveMinimum',\n      value: isNumber,\n    },\n  ],\n  get integer() {\n    return this.number;\n  },\n};\n\nexport function getValidations(schema: SchemaFragment, types: Set<SchemaNodeKind>): Record<string, unknown> {\n  return observable.object(getMatchingValidations(schema, VALIDATION_TYPES, types));\n}\n","import { observable } from 'mobx';\n\nimport type { SchemaCombinerName, SchemaNodeKind } from '../../nodes';\nimport type { SchemaFragment } from '../../types';\nimport { SharedSchemaDialect } from '../Base/SharedDialect';\nimport { getAnnotations } from './accessors/getAnnotations';\nimport { getCombiners } from './accessors/getCombiners';\nimport { getValidations } from './accessors/getValidations';\n\nexport class OAS2SchemaObjectDialect extends SharedSchemaDialect {\n  public getCombiners(fragment: SchemaFragment): Set<SchemaCombinerName> {\n    return observable.set(getCombiners(fragment));\n  }\n\n  public getAnnotations(fragment: SchemaFragment): Record<string, unknown> {\n    return observable.object({\n      ...super.getAnnotations(fragment),\n      ...getAnnotations(fragment),\n    });\n  }\n\n  public getValidations(fragment: SchemaFragment, types: Set<SchemaNodeKind>): Record<string, unknown> {\n    return observable({\n      ...super.getValidations(fragment, types),\n      ...getValidations(fragment, types),\n    });\n  }\n}\n","import { makeObservable, observable } from 'mobx';\n\nimport type { SchemaFragment } from '../types';\nimport type { MirroredRegularNode } from './mirrored';\nimport type { RegularNode } from './RegularNode';\nimport type { RootNode } from './RootNode';\n\nexport abstract class BaseNode {\n  public readonly id: string;\n\n  public parent: RegularNode | RootNode | MirroredRegularNode | null = null;\n  public readonly subpath: string[];\n\n  public get path(): ReadonlyArray<string> {\n    return this.parent === null ? this.subpath : [...this.parent.path, ...this.subpath];\n  }\n\n  public get depth(): number {\n    return this.parent === null ? 0 : this.parent.depth + 1;\n  }\n\n  protected constructor(public readonly fragment: SchemaFragment) {\n    this.id = `json-schema-tree-id-${Math.random().toString(36).slice(2)}`;\n    this.subpath = [];\n\n    makeObservable(this, {\n      subpath: observable.shallow,\n    });\n  }\n\n  public abstract toJSON(): SchemaFragment;\n}\n","import type { SchemaFragment } from '../../types';\nimport { BaseNode } from '../BaseNode';\nimport type { ReferenceNode } from '../ReferenceNode';\n\nexport class MirroredReferenceNode extends BaseNode implements ReferenceNode {\n  constructor(public readonly mirroredNode: ReferenceNode) {\n    super(mirroredNode.fragment);\n  }\n\n  public toJSON(): SchemaFragment {\n    return this.mirroredNode.fragment;\n  }\n\n  get error() {\n    return this.mirroredNode.error;\n  }\n\n  get value() {\n    return this.mirroredNode.value;\n  }\n\n  public get external() {\n    return this.mirroredNode.external;\n  }\n}\n","import { action, computed, observable, reaction } from 'mobx';\n\nimport type { SchemaDialect } from '../../dialects/SchemaDialect';\nimport { isRegularNode } from '../../guards';\nimport type { SchemaFragment } from '../../types';\nimport { isNonNullable } from '../../utils';\nimport { BaseNode } from '../BaseNode';\nimport type { ReferenceNode } from '../ReferenceNode';\nimport type { RegularNode } from '../RegularNode';\nimport type { SchemaCombinerName, SchemaNodeKind } from '../types';\nimport { MirroredReferenceNode } from './MirroredReferenceNode';\n\nexport class MirroredRegularNode extends BaseNode implements RegularNode {\n  public readonly dialect!: SchemaDialect;\n  public readonly $id!: string;\n  public readonly types!: Set<SchemaNodeKind>;\n  public readonly primaryType!: SchemaNodeKind | null;\n  public readonly combiners!: Set<SchemaCombinerName>;\n\n  public readonly required!: string[] | null;\n  public readonly enum!: Set<unknown>;\n  public readonly format!: string | null;\n  public readonly title!: string | null;\n  public readonly deprecated!: boolean;\n\n  public readonly annotations!: Record<string, unknown>;\n  public readonly validations!: Record<string, unknown>;\n\n  public readonly simple!: boolean;\n  public readonly unknown!: boolean;\n\n  private readonly cache: WeakMap<RegularNode | ReferenceNode, MirroredRegularNode | MirroredReferenceNode>;\n\n  constructor(public readonly mirroredNode: RegularNode) {\n    super(mirroredNode.fragment);\n\n    this.cache = new WeakMap();\n\n    this._this = new Proxy(this, {\n      get(target, key) {\n        if (key in target) {\n          return target[key];\n        }\n\n        if (key in mirroredNode) {\n          return Reflect.get(mirroredNode, key, mirroredNode);\n        }\n\n        return;\n      },\n\n      has(target, key) {\n        return key in target || key in mirroredNode;\n      },\n    });\n\n    return this._this;\n  }\n\n  public toJSON(): SchemaFragment {\n    return {\n      $ref: this.mirroredNode.$id,\n    };\n  }\n\n  private readonly _this: MirroredRegularNode;\n\n  @observable.shallow\n  private _children?: (MirroredRegularNode | MirroredReferenceNode)[];\n\n  private _reaction: any;\n\n  @computed\n  public get children(): (MirroredRegularNode | MirroredReferenceNode)[] | null | undefined {\n    const referencedChildren = this.mirroredNode.children;\n\n    if (!isNonNullable(referencedChildren)) {\n      return referencedChildren;\n    }\n\n    if (!this._reaction) {\n      console.log('setting up reaction', referencedChildren);\n      // todo: setup reaction\n      this._reaction = reaction(\n        () => referencedChildren,\n        action(() => {\n          console.log('foo!');\n        }),\n      );\n    }\n\n    if (this._children === void 0) {\n      this._children = [];\n    } else {\n      this._children.length = 0;\n    }\n\n    const children: (MirroredRegularNode | MirroredReferenceNode)[] = this._children;\n    for (const child of referencedChildren) {\n      // this is to avoid pointing at nested mirroring\n      const cached = this.cache.get(child);\n\n      if (cached !== void 0) {\n        children.push(cached);\n        continue;\n      }\n\n      const mirroredChild = isRegularNode(child) ? new MirroredRegularNode(child) : new MirroredReferenceNode(child);\n\n      mirroredChild.parent = this._this;\n      // @ts-expect-error\n      mirroredChild.subpath = child.subpath;\n      this.cache.set(child, mirroredChild);\n      children.push(mirroredChild);\n    }\n\n    return children;\n  }\n}\n","export function unwrapStringOrNull(value: unknown): string | null {\n  return typeof value === 'string' ? value : null;\n}\n\nexport function unwrapArrayOrNull(value: unknown): unknown[] {\n  return Array.isArray(value) ? value : [];\n}\n","import { isLocalRef } from '@stoplight/json';\n\nimport { unwrapStringOrNull } from '../dialects/accessors/unwrap';\nimport { isReferenceNode, isSchemaNode } from '../guards';\nimport type { SchemaFragment } from '../types';\nimport { BaseNode } from './BaseNode';\n\nexport class ReferenceNode extends BaseNode {\n  public readonly value: string | null;\n\n  constructor(fragment: SchemaFragment, public readonly error: string | null) {\n    super(fragment);\n\n    this.value = unwrapStringOrNull(fragment.$ref);\n  }\n\n  public toJSON(): SchemaFragment {\n    return this.fragment;\n  }\n\n  public get external() {\n    return this.value !== null && !isLocalRef(this.value);\n  }\n\n  static [Symbol.hasInstance](instance: unknown) {\n    return isSchemaNode(instance) && isReferenceNode(instance);\n  }\n}\n","import { SchemaNodeKind } from '../../nodes/types';\nimport type { SchemaFragment } from '../../types';\n\nexport function getPrimaryType(fragment: SchemaFragment, types: Set<SchemaNodeKind>) {\n  if (types.size > 0) {\n    if (types.has(SchemaNodeKind.Object)) {\n      return SchemaNodeKind.Object;\n    }\n\n    if (types.has(SchemaNodeKind.Array)) {\n      return SchemaNodeKind.Array;\n    }\n\n    return types.values().next().value;\n  }\n\n  return null;\n}\n","import { SchemaNodeKind } from '../../../nodes/types';\n\nconst VALID_TYPES = Object.values(SchemaNodeKind);\n\nexport const isValidType = (maybeType: unknown): maybeType is SchemaNodeKind =>\n  typeof maybeType === 'string' && VALID_TYPES.includes(maybeType as SchemaNodeKind);\n","import { SchemaNodeKind } from '../../nodes/types';\nimport type { SchemaFragment } from '../../types';\n\nexport function inferType(fragment: SchemaFragment): SchemaNodeKind | null {\n  if ('properties' in fragment || 'additionalProperties' in fragment || 'patternProperties' in fragment) {\n    return SchemaNodeKind.Object;\n  }\n\n  if ('items' in fragment || 'additionalItems' in fragment) {\n    return SchemaNodeKind.Array;\n  }\n\n  return null;\n}\n","import { observable } from 'mobx';\n\nimport type { SchemaNodeKind } from '../../nodes/types';\nimport type { SchemaFragment } from '../../types';\nimport { isValidType } from './guards/isValidType';\nimport { inferType } from './inferType';\n\nexport function getTypes(fragment: SchemaFragment): Set<SchemaNodeKind> {\n  if ('type' in fragment) {\n    if (Array.isArray(fragment.type)) {\n      return observable.set(fragment.type.filter(isValidType));\n    } else if (isValidType(fragment.type)) {\n      return observable.set([fragment.type]);\n    }\n  }\n\n  const inferredType = inferType(fragment);\n  if (inferredType !== null) {\n    return observable.set([inferredType]);\n  }\n\n  return observable.set([]);\n}\n","import type { Dictionary } from '@stoplight/types';\nimport { computed, makeObservable, observable } from 'mobx';\n\nimport { getPrimaryType } from '../dialects/accessors/getPrimaryType';\nimport { getTypes } from '../dialects/accessors/getTypes';\nimport { unwrapArrayOrNull, unwrapStringOrNull } from '../dialects/accessors/unwrap';\nimport type { SchemaDialect } from '../dialects/SchemaDialect';\nimport { isRegularNode, isSchemaNode } from '../guards';\nimport type { SchemaFragment } from '../types';\nimport { BaseNode } from './BaseNode';\nimport type { ReferenceNode } from './ReferenceNode';\nimport { MirroredSchemaNode, SchemaCombinerName, SchemaNodeKind } from './types';\n\nexport class RegularNode extends BaseNode {\n  public readonly $id: string;\n  public readonly types: Set<SchemaNodeKind>;\n  public readonly combiners: Set<SchemaCombinerName>;\n\n  public readonly enum: Set<unknown>; // https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1\n  public format: string | null; // https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-7\n  public title: string | null;\n  public children: (RegularNode | ReferenceNode | MirroredSchemaNode)[] | null | undefined;\n\n  public readonly annotations: Record<string, unknown>;\n\n  constructor(public readonly fragment: SchemaFragment, public readonly dialect: SchemaDialect) {\n    super(fragment);\n\n    this.$id = unwrapStringOrNull(fragment.$id) ?? this.id;\n    this.types = getTypes(fragment);\n    this.combiners = dialect.getCombiners(fragment);\n\n    this.enum = observable.set('const' in fragment ? [fragment.const] : unwrapArrayOrNull(fragment.enum));\n    this.format = unwrapStringOrNull(fragment.format);\n    this.title = unwrapStringOrNull(fragment.title);\n\n    this.annotations = dialect.getAnnotations(fragment);\n    this.children = void 0;\n\n    makeObservable(this, {\n      format: observable,\n      title: observable,\n    });\n  }\n\n  public toJSON(): SchemaFragment {\n    const children = this.children?.reduce((children, node) => {\n      const [entry, key] = node.subpath;\n      if (node.subpath.length === 1) {\n        children[entry] = node.toJSON();\n        return children;\n      } else if (!(entry in children)) {\n        // todo: tuples\n        children[entry] = {};\n      }\n\n      children[entry][key] = node.toJSON();\n\n      return children;\n    }, {});\n\n    return {\n      ...this.fragment,\n      ...(this.format !== null && { format: this.format }),\n      ...(this.title !== null && { title: this.title }),\n      $id: this.$id,\n      ...children,\n    };\n  }\n\n  @computed\n  public get validations(): Dictionary<unknown> {\n    return this.dialect.getValidations(this.fragment, this.types);\n  }\n\n  @computed\n  public get primaryType(): SchemaNodeKind | null {\n    // object (first choice) or array (second option), primitive last\n    return getPrimaryType(this.fragment, this.types);\n  }\n\n  @computed\n  public get simple() {\n    return (\n      this.primaryType !== SchemaNodeKind.Array && this.primaryType !== SchemaNodeKind.Object && this.combiners === null\n    );\n  }\n\n  public get unknown() {\n    return (\n      this.types === null &&\n      this.combiners === null &&\n      this.format === null &&\n      this.enum === null &&\n      Object.keys(this.annotations).length + Object.keys(this.validations).length === 0\n    );\n  }\n\n  static [Symbol.hasInstance](instance: unknown) {\n    return isSchemaNode(instance) && isRegularNode(instance);\n  }\n}\n","import type { SchemaFragment } from '../types';\nimport { BaseNode } from './BaseNode';\nimport type { SchemaNode } from './types';\n\nexport class RootNode extends BaseNode {\n  public readonly parent = null;\n  public readonly children: SchemaNode[];\n\n  constructor(public readonly fragment: SchemaFragment) {\n    super(fragment);\n    this.children = [];\n  }\n\n  public toJSON(): SchemaFragment {\n    if (this.children.length !== 1) {\n      return this.children.map(child => child.toJSON());\n    }\n\n    return this.children[0].toJSON();\n  }\n}\n","import {\n  MirroredReferenceNode,\n  MirroredRegularNode,\n  MirroredSchemaNode,\n  ReferenceNode,\n  RegularNode,\n  RootNode,\n  SchemaNode,\n} from '../nodes';\n\nexport function isSchemaNode(node: unknown): node is SchemaNode {\n  const name = Object.getPrototypeOf(node).constructor.name;\n  return (\n    name === RootNode.name ||\n    name === RegularNode.name ||\n    name === MirroredRegularNode.name ||\n    name === ReferenceNode.name ||\n    name === MirroredReferenceNode.name\n  );\n}\n\nexport function isRootNode(node: SchemaNode): node is RootNode {\n  return Object.getPrototypeOf(node).constructor.name === 'RootNode';\n}\n\nexport function isRegularNode(node: SchemaNode): node is RegularNode {\n  return 'types' in node && 'primaryType' in node && 'combiners' in node;\n}\n\nexport function isMirroredNode(node: SchemaNode): node is MirroredSchemaNode {\n  return 'mirroredNode' in node;\n}\n\nexport function isReferenceNode(node: SchemaNode): node is ReferenceNode {\n  return 'external' in node && 'value' in node;\n}\n","export class ResolvingError extends ReferenceError {\n  public readonly name = 'ResolvingError';\n}\n\nexport class MergingError extends Error {\n  public readonly name = 'MergingError';\n}\n","import { pathToPointer, stringify } from '@stoplight/json';\n\nimport { ResolvingError } from '../errors';\nimport type { SchemaFragment } from '../types';\nimport type { WalkerRefResolver, WalkingOptions } from '../walker/types';\n\nconst resolveAllOf = require('@stoplight/json-schema-merge-allof');\n\nconst store = new WeakMap<WalkerRefResolver, WeakMap<SchemaFragment, string[]>>();\n\nfunction _mergeAllOf(fragment: SchemaFragment, path: string[], resolveRef: WalkerRefResolver | null): SchemaFragment {\n  return resolveAllOf(fragment, {\n    deep: false,\n    resolvers: resolveAllOf.stoplightResolvers,\n    ...(resolveRef !== null\n      ? {\n          $refResolver($ref: unknown) {\n            if (typeof $ref !== 'string') {\n              return {};\n            }\n\n            if (pathToPointer(path).startsWith($ref)) {\n              throw new ResolvingError('Circular reference detected');\n            }\n\n            const allRefs = store.get(resolveRef)!;\n            let schemaRefs = allRefs.get(fragment);\n\n            if (schemaRefs === void 0) {\n              schemaRefs = [$ref];\n              allRefs.set(fragment, schemaRefs);\n            } else if (schemaRefs.includes($ref)) {\n              const safelyResolved = JSON.parse(stringify(resolveRef(null, $ref)));\n              return 'allOf' in safelyResolved ? _mergeAllOf(safelyResolved, path, resolveRef) : safelyResolved;\n            } else {\n              schemaRefs.push($ref);\n            }\n\n            const resolved = resolveRef(null, $ref);\n\n            if (Array.isArray(resolved.allOf)) {\n              for (const member of resolved.allOf) {\n                if (typeof member.$ref === 'string' && schemaRefs.includes(member.$ref)) {\n                  throw new ResolvingError('Circular reference detected');\n                }\n              }\n            }\n\n            return resolved;\n          },\n        }\n      : null),\n  });\n}\n\nexport function mergeAllOf(fragment: SchemaFragment, path: string[], walkingOptions: WalkingOptions) {\n  if (walkingOptions.resolveRef !== null && !store.has(walkingOptions.resolveRef)) {\n    store.set(walkingOptions.resolveRef, new WeakMap());\n  }\n\n  return _mergeAllOf(fragment, path, walkingOptions.resolveRef);\n}\n","import { SchemaCombinerName } from '../nodes/types';\nimport type { SchemaFragment } from '../types';\nimport type { WalkingOptions } from '../walker/types';\nimport { mergeAllOf } from './mergeAllOf';\n\nexport function mergeOneOrAnyOf(\n  fragment: SchemaFragment,\n  path: string[],\n  walkingOptions: WalkingOptions,\n): SchemaFragment[] {\n  const combiner = SchemaCombinerName.OneOf in fragment ? SchemaCombinerName.OneOf : SchemaCombinerName.AnyOf;\n  const items = fragment[combiner];\n\n  if (!Array.isArray(items)) return []; // just in case\n\n  const merged: SchemaFragment[] = [];\n\n  if (Array.isArray(fragment.allOf) && Array.isArray(items)) {\n    for (const item of items) {\n      merged.push({\n        allOf: [...fragment.allOf, item],\n      });\n    }\n\n    return merged;\n  } else {\n    for (const item of items) {\n      const prunedSchema = { ...fragment };\n      delete prunedSchema[combiner];\n\n      const resolvedItem =\n        typeof item.$ref === 'string' && walkingOptions.resolveRef !== null\n          ? walkingOptions.resolveRef(null, item.$ref)\n          : item;\n\n      if (Object.keys(prunedSchema).length === 0) {\n        merged.push(resolvedItem);\n      } else {\n        const mergedSchema = {\n          allOf: [prunedSchema, resolvedItem],\n        };\n\n        try {\n          merged.push(mergeAllOf(mergedSchema, path, walkingOptions));\n        } catch {\n          merged.push(mergedSchema);\n        }\n      }\n    }\n  }\n\n  return merged;\n}\n","import { EventEmitter } from '@stoplight/lifecycle';\nimport type { Dictionary } from '@stoplight/types';\nimport createMagicError from 'magic-error';\nimport { makeObservable, observable, runInAction } from 'mobx';\n\nimport type { SchemaDialect } from '../dialects/SchemaDialect';\nimport { MergingError } from '../errors';\nimport { isMirroredNode, isReferenceNode, isRegularNode, isRootNode } from '../guards';\nimport { mergeAllOf } from '../mergers/mergeAllOf';\nimport { mergeOneOrAnyOf } from '../mergers/mergeOneOrAnyOf';\nimport { MirroredReferenceNode, MirroredRegularNode, MirroredSchemaNode, ReferenceNode, RegularNode } from '../nodes';\nimport type { RootNode } from '../nodes/RootNode';\nimport { SchemaCombinerName, SchemaNode, SchemaNodeKind } from '../nodes/types';\nimport type { SchemaFragment } from '../types';\nimport { isNonNullable, isObjectLiteral } from '../utils/guards';\nimport type { WalkerEmitter, WalkerHookAction, WalkerHookHandler, WalkerSnapshot, WalkingOptions } from './types';\n\ntype InternalWalkerState = {\n  depth: number;\n  pathLength: number;\n  schemaNode: RegularNode | RootNode;\n};\n\ntype ProcessedFragment = SchemaFragment | SchemaFragment[];\n\nexport class Walker extends EventEmitter<WalkerEmitter> {\n  public readonly path: string[];\n  public depth: number;\n\n  protected fragment: SchemaFragment;\n  protected schemaNode: RegularNode | RootNode;\n  protected readonly schemaDialect: SchemaDialect;\n\n  private processedFragments: WeakMap<ProcessedFragment, SchemaNode>;\n  private readonly hooks: Partial<Dictionary<WalkerHookHandler, WalkerHookAction>>;\n\n  constructor(protected readonly root: RootNode, protected readonly walkingOptions: WalkingOptions) {\n    super();\n\n    this.schemaDialect = walkingOptions.schemaDialect;\n    this.path = [];\n    this.depth = -1;\n    this.fragment = root.fragment;\n    this.schemaNode = root;\n    this.processedFragments = new WeakMap<SchemaFragment, SchemaNode>();\n\n    this.hooks = {};\n  }\n\n  public destroy() {\n    this.path.length = 0;\n    this.depth = -1;\n    this.fragment = this.root.fragment;\n    this.schemaNode = this.root;\n    this.processedFragments = new WeakMap<SchemaFragment, RegularNode | ReferenceNode>();\n  }\n\n  public loadSnapshot(snapshot: WalkerSnapshot) {\n    this.path.splice(0, this.path.length, ...snapshot.path);\n    this.depth = snapshot.depth;\n    this.fragment = snapshot.fragment;\n    this.schemaNode = snapshot.schemaNode;\n  }\n\n  public saveSnapshot(): WalkerSnapshot {\n    return {\n      depth: this.depth,\n      fragment: this.fragment,\n      schemaNode: this.schemaNode,\n      path: this.path.slice(),\n    };\n  }\n\n  public hookInto(action: WalkerHookAction, handler: WalkerHookHandler) {\n    this.hooks[action] = handler;\n  }\n\n  public restoreWalkerAtNode(node: RegularNode) {\n    this.processedFragments.delete(node.fragment);\n    this.path.splice(0, this.path.length, ...node.path);\n    this.depth = node.depth;\n    this.fragment = node.fragment;\n    this.schemaNode = node;\n  }\n\n  public walk(): void {\n    const { depth: initialDepth, fragment } = this;\n    let { schemaNode: initialSchemaNode } = this;\n\n    if (initialDepth === -1 && Object.keys(fragment).length === 0) {\n      // empty schema, nothing to do\n      return;\n    }\n\n    while (isMirroredNode(initialSchemaNode)) {\n      if (!isRegularNode(initialSchemaNode.mirroredNode)) {\n        return;\n      }\n\n      if (initialSchemaNode.mirroredNode.children === void 0) {\n        this.restoreWalkerAtNode(initialSchemaNode.mirroredNode);\n        initialSchemaNode = this.schemaNode;\n        this.depth = initialDepth;\n      } else {\n        return;\n      }\n    }\n\n    const state = this.dumpInternalWalkerState();\n\n    super.emit('enterFragment', fragment);\n    const [schemaNode, initialFragment] = this.processFragment();\n    super.emit('enterNode', schemaNode);\n\n    const actualNode = isMirroredNode(schemaNode) ? schemaNode.mirroredNode : schemaNode;\n    this.processedFragments.set(schemaNode.fragment, actualNode);\n    this.processedFragments.set(initialFragment, actualNode);\n\n    this.fragment = schemaNode.fragment;\n    this.depth = initialDepth + 1;\n\n    const isIncluded = this.hooks.filter?.(schemaNode);\n\n    if (isIncluded === false) {\n      super.emit('skipNode', schemaNode);\n      return;\n    }\n\n    if (!isRootNode(schemaNode)) {\n      schemaNode.parent = initialSchemaNode;\n      runInAction(() => {\n        schemaNode.subpath.push(...this.path.slice(initialSchemaNode.path.length));\n      });\n    }\n\n    if ('children' in initialSchemaNode && !isRootNode(schemaNode)) {\n      if (initialSchemaNode.children === void 0) {\n        (initialSchemaNode as RegularNode).children = [schemaNode];\n        makeObservable(initialSchemaNode, {\n          children: observable,\n        }); // todo: dispose\n      } else {\n        runInAction(() => {\n          initialSchemaNode.children!.push(schemaNode);\n        });\n      }\n    }\n\n    super.emit('includeNode', schemaNode);\n\n    if (isRegularNode(schemaNode)) {\n      this.schemaNode = schemaNode;\n\n      if (this.hooks.stepIn?.(schemaNode) !== false) {\n        super.emit('stepInNode', schemaNode);\n        this.walkNodeChildren();\n        super.emit('stepOutNode', schemaNode);\n      } else {\n        super.emit('stepOverNode', schemaNode);\n      }\n    }\n\n    super.emit('exitNode', schemaNode);\n    this.restoreInternalWalkerState(state);\n    super.emit('exitFragment', fragment);\n  }\n\n  protected dumpInternalWalkerState(): InternalWalkerState {\n    return {\n      depth: this.depth,\n      pathLength: this.path.length,\n      schemaNode: this.schemaNode,\n    };\n  }\n\n  protected restoreInternalWalkerState({ depth, pathLength, schemaNode }: InternalWalkerState) {\n    this.depth = depth;\n    this.path.length = pathLength;\n    this.schemaNode = schemaNode;\n  }\n\n  protected walkNodeChildren(): void {\n    const { fragment, schemaNode } = this;\n\n    if (!isRegularNode(schemaNode)) return;\n\n    const state = this.dumpInternalWalkerState();\n\n    if (schemaNode.combiners !== null) {\n      for (const combiner of schemaNode.combiners) {\n        const items = fragment[combiner];\n        if (!Array.isArray(items)) continue;\n\n        let i = -1;\n        for (const item of items) {\n          i++;\n          if (!isObjectLiteral(item)) continue;\n          this.fragment = item;\n          this.restoreInternalWalkerState(state);\n          this.path.push(combiner, String(i));\n          this.walk();\n        }\n      }\n    }\n\n    switch (schemaNode.primaryType) {\n      case SchemaNodeKind.Array:\n        if (Array.isArray(fragment.items)) {\n          let i = -1;\n          for (const item of fragment.items) {\n            i++;\n            if (!isObjectLiteral(item)) continue;\n            this.fragment = item;\n            this.restoreInternalWalkerState(state);\n            this.path.push('items', String(i));\n            this.walk();\n          }\n        } else if (isObjectLiteral(fragment.items)) {\n          this.fragment = fragment.items;\n          this.restoreInternalWalkerState(state);\n          this.path.push('items');\n          this.walk();\n        }\n\n        break;\n      case SchemaNodeKind.Object:\n        if (isObjectLiteral(fragment.properties)) {\n          for (const key of Object.keys(fragment.properties)) {\n            const value = fragment.properties[key];\n            if (!isObjectLiteral(value)) continue;\n            this.fragment = value;\n            this.restoreInternalWalkerState(state);\n            this.path.push('properties', key);\n            this.walk();\n          }\n        }\n\n        if (isObjectLiteral(fragment.patternProperties)) {\n          for (const key of Object.keys(fragment.patternProperties)) {\n            const value = fragment.patternProperties[key];\n            if (!isObjectLiteral(value)) continue;\n            this.fragment = value;\n            this.restoreInternalWalkerState(state);\n            this.path.push('patternProperties', key);\n            this.walk();\n          }\n        }\n\n        break;\n    }\n\n    this.schemaNode = schemaNode;\n  }\n\n  protected retrieveFromFragment(fragment: ProcessedFragment): [MirroredSchemaNode, ProcessedFragment] | void {\n    const processedSchemaNode = this.processedFragments.get(fragment);\n    if (processedSchemaNode !== void 0) {\n      if (isRegularNode(processedSchemaNode)) {\n        return [new MirroredRegularNode(processedSchemaNode), fragment];\n      }\n\n      if (isReferenceNode(processedSchemaNode)) {\n        return [new MirroredReferenceNode(processedSchemaNode), fragment];\n      }\n\n      // whoops, we don't know what to do with it\n      throw new TypeError('Cannot mirror the node');\n    }\n  }\n\n  protected processFragment(): [SchemaNode, ProcessedFragment] {\n    const { walkingOptions, path } = this;\n    let { fragment } = this;\n\n    let retrieved = isNonNullable(fragment) ? this.retrieveFromFragment(fragment) : null;\n\n    if (retrieved) {\n      return retrieved;\n    }\n\n    if ('$ref' in fragment) {\n      if (typeof fragment.$ref !== 'string') {\n        return [new ReferenceNode(fragment, '$ref is not a string'), fragment];\n      } else if (walkingOptions.resolveRef !== null) {\n        try {\n          fragment = walkingOptions.resolveRef(path, fragment.$ref);\n        } catch (ex) {\n          super.emit('error', createMagicError(ex));\n          return [new ReferenceNode(fragment, ex?.message ?? 'Unknown resolving error'), fragment];\n        }\n      } else {\n        return [new ReferenceNode(fragment, null), fragment];\n      }\n    }\n\n    let initialFragment: ProcessedFragment = fragment;\n    if (walkingOptions.mergeAllOf && SchemaCombinerName.AllOf in fragment) {\n      try {\n        if (Array.isArray(fragment.allOf)) {\n          initialFragment = fragment.allOf;\n        }\n\n        fragment = mergeAllOf(fragment, path, walkingOptions);\n      } catch (ex) {\n        initialFragment = fragment;\n        super.emit('error', createMagicError(new MergingError(ex?.message ?? 'Unknown merging error')));\n        // no the end of the world - we will render raw unprocessed fragment\n      }\n    }\n\n    if (SchemaCombinerName.OneOf in fragment || SchemaCombinerName.AnyOf in fragment) {\n      try {\n        const merged = mergeOneOrAnyOf(fragment, path, walkingOptions);\n        if (merged.length === 1) {\n          return [new RegularNode(merged[0], this.schemaDialect), initialFragment];\n        } else {\n          const combiner = SchemaCombinerName.OneOf in fragment ? SchemaCombinerName.OneOf : SchemaCombinerName.AnyOf;\n          return [\n            new RegularNode(\n              {\n                [combiner]: merged,\n              },\n              this.schemaDialect,\n            ),\n            initialFragment,\n          ];\n        }\n      } catch (ex) {\n        super.emit('error', createMagicError(new MergingError(ex?.message ?? 'Unknown merging error')));\n        // no the end of the world - we will render raw unprocessed fragment\n      }\n    }\n\n    retrieved = isNonNullable(fragment) ? this.retrieveFromFragment(initialFragment) : null;\n\n    if (retrieved) {\n      return retrieved;\n    }\n\n    return [new RegularNode(fragment, this.schemaDialect), initialFragment];\n  }\n}\n","import { extractPointerFromRef, extractSourceFromRef, resolveInlineRef } from '@stoplight/json';\n\nimport { SharedSchemaDialect } from '../dialects/Base/SharedDialect';\nimport { ResolvingError } from '../errors';\nimport { RootNode } from '../nodes/RootNode';\nimport type { SchemaFragment } from '../types';\nimport { isObjectLiteral } from '../utils';\nimport { Walker } from '../walker';\nimport type { WalkerRefResolver } from '../walker/types';\nimport type { SchemaTreeOptions } from './types';\n\nexport class SchemaTree {\n  public walker: Walker;\n  public root: RootNode;\n\n  constructor(public schema: SchemaFragment, protected readonly opts?: Partial<SchemaTreeOptions>) {\n    this.root = new RootNode(schema);\n    this.walker = new Walker(this.root, {\n      mergeAllOf: this.opts?.mergeAllOf !== false,\n      resolveRef: opts?.refResolver === null ? null : this.resolveRef,\n      schemaDialect: opts?.dialect ?? new SharedSchemaDialect(),\n    });\n  }\n\n  public toJSON(): SchemaFragment {\n    return this.root.toJSON();\n  }\n\n  public destroy() {\n    this.root.children.length = 0;\n    this.walker.destroy();\n  }\n\n  public populate() {\n    this.invokeWalker(this.walker);\n  }\n\n  public invokeWalker(walker: Walker) {\n    walker.walk();\n  }\n\n  protected resolveRef: WalkerRefResolver = (path, $ref) => {\n    const seenRefs: string[] = [];\n    let cur$ref: unknown = $ref;\n    let resolvedValue!: SchemaFragment;\n\n    while (typeof cur$ref === 'string') {\n      if (seenRefs.includes(cur$ref)) {\n        break;\n      }\n\n      seenRefs.push(cur$ref);\n      resolvedValue = this._resolveRef(path, cur$ref);\n      cur$ref = resolvedValue.$ref;\n    }\n\n    return resolvedValue;\n  };\n\n  private _resolveRef: WalkerRefResolver = (path, $ref) => {\n    const source = extractSourceFromRef($ref);\n    const pointer = extractPointerFromRef($ref);\n    const refResolver = this.opts?.refResolver;\n\n    if (typeof refResolver === 'function') {\n      return refResolver({ source, pointer }, path, this.schema);\n    } else if (source !== null) {\n      throw new ResolvingError('Cannot dereference external references');\n    } else if (pointer === null) {\n      throw new ResolvingError('The pointer is empty');\n    } else if (isObjectLiteral(this.schema)) {\n      const value = resolveInlineRef(this.schema, pointer);\n      if (!isObjectLiteral(value)) {\n        throw new ResolvingError('Invalid value');\n      }\n\n      return value;\n    } else {\n      throw new ResolvingError('Unexpected input');\n    }\n  };\n}\n"],"names":["observable","getAnnotations","SchemaNodeKind","SchemaCombinerName","getTypeValidations","VALIDATION_TYPES","getValidations","getCombiners","makeObservable","reaction","action","computed","isLocalRef","pathToPointer","stringify","EventEmitter","runInAction","extractSourceFromRef","extractPointerFromRef","resolveInlineRef"],"mappings":"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"}